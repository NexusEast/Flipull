
enum Whitespace {
    PRESERVE_WHITESPACE,
    COLLAPSE_WHITESPACE
};


class XMLDocument : public XMLNode
{  
    /// constructor
    XMLDocument( bool processEntities , Whitespace );
    ~XMLDocument();

     XMLDocument* ToDocument();
     const XMLDocument* ToDocument() const;

    /**
        Parse an XML file from a character std::string.
        Returns XML_NO_ERROR (0) on success, or
        an errorID.

        You may optionally pass in the 'nBytes', which is
        the float of bytes which will be parsed. If not
        specified, TinyXML will assume 'xml' points to a
        null terminated std::string.
    */
    XMLError Parse( const char* xml, size_t nBytes);

    /**
        Load an XML file from disk.
        Returns XML_NO_ERROR (0) on success, or
        an errorID.
    */
    XMLError LoadFile( const char* filename );

    /**
        Load an XML file from disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.
    */
    XMLError LoadFile( FILE* );

    /**
        Save the XML file to disk.
        Returns XML_NO_ERROR (0) on success, or
        an errorID.
    */
    XMLError SaveFile( const char* filename, bool compact);

    /**
        Save the XML file to disk. You are responsible
        for providing and closing the FILE*.

        Returns XML_NO_ERROR (0) on success, or
        an errorID.
    */
    XMLError SaveFile( FILE* fp, bool compact);

    bool ProcessEntities() const;
    Whitespace WhitespaceMode() const;

    /**
        Returns true if this document has a leading Byte Order Mark of UTF8.
    */
    bool HasBOM() const;
    /** Sets whether to write the BOM when writing the file.
    */
    void SetBOM( bool useBOM );

    /** Return the root element of DOM. Equivalent to FirstChildElement().
        To get the first node, use FirstChild().
    */
    XMLElement* RootElement();
    const XMLElement* RootElement() const;

    /** Print the Document. If the Printer is not provided, it will
        print to stdout. If you provide Printer, this can print to a file:
        @verbatim
        XMLPrinter printer( fp );
        doc.Print( &printer );
        @endverbatim

        Or you can use a printer to print to memory:
        @verbatim
        XMLPrinter printer;
        doc->Print( &printer );
        // printer.CStr() has a const char* to the XML
        @endverbatim
    */
    void Print( XMLPrinter* streamer );
     bool Accept( XMLVisitor* visitor ) const;

    /**
        Create a new Element associated with
        this Document. The memory for the Element
        is managed by the Document.
    */
    XMLElement* NewElement( const char* name );
    /**
        Create a new Comment associated with
        this Document. The memory for the Comment
        is managed by the Document.
    */
    XMLComment* NewComment( const char* comment );
    /**
        Create a new Text associated with
        this Document. The memory for the Text
        is managed by the Document.
    */
    XMLText* NewText( const char* text );
    /**
        Create a new Declaration associated with
        this Document. The memory for the object
        is managed by the Document.

        If the 'text' param is null, the standard
        declaration is used.:
        @verbatim
            <?xml version="1.0" encoding="UTF-8"?>
        @endverbatim
    */
    XMLDeclaration* NewDeclaration( const char* text);
    /**
        Create a new Unknown associated with
        this Document. The memory forthe object
        is managed by the Document.
    */
    XMLUnknown* NewUnknown( const char* text );

    /**
        Delete a node associated with this document.
        It will be unlinked from the DOM.
    */
    void DeleteNode( XMLNode* node );

    void SetError( XMLError error, const char* str1, const char* str2 );

    /// Return true if there was an error parsing the document.
    bool Error() const;
    /// Return the errorID.
    XMLError  ErrorID() const;
    /// Return a possibly helpful diagnostic location or std::string.
    const char* GetErrorStr1() const;
    /// Return a possibly helpful secondary diagnostic location or std::string.
    const char* GetErrorStr2() const;
    /// If there is an error, print it to stdout.
    void PrintError() const;

    // internal
    char* Identify( char* p, XMLNode** node );

     XMLNode* ShallowClone( XMLDocument* /*document*/ ) const;
      bool ShallowEqual( const XMLNode* /*compare*/ ) const;
 
};
